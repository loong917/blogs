---
id: 2025022601
title: Redis 执行 Lua，如何保证原子性？
date: 2025年2月26日
image: code.svg
tags: ["programming"]
---


### 目录

 - 什么是原子性 ? 
 - Redis 如何执行 Lua ? 
 - Redis 执行 Lua 注意事项


### 什么是原子性？

在讨论 Redis Lua 脚本的原子性时，需要区分两种类型的原子性：

- 执行原子性（Execution Atomicity）

脚本作为一个整体被执行，没有其他命令可以干扰其执行。这类似于 Redis 中单个命令的特性，由于单线程模型，脚本的执行是隔离的，其他客户端必须等待。

- 事务性原子性（Transactional Atomicity）

脚本的操作要么全部成功，要么全部失败，具有"全或无"的特性。如果某个操作失败，前面的操作应该自动回滚。比如关系型数据库RDBMS的原子性，也就是 ACID (Atomicity、Consistency、Isolation、Durability) 中 Atomicity 这项特性。ACID中的原子性指是事务中的所有操作要么全部执行成功，要么全部失败回滚。

- 执行原子性与事务性原子性的差异

| 类型         | 定义                                       | Lua脚本是否支持 | 备注                                        |
| ------------ | ------------------------------------------ | --------------- | ------------------------------------------- |
| 执行原子性   | 脚本作为一个整体执行，无其他命令干扰       | 是              | 由 Redis 单线程模型保证，类似单个命令的执行 |
| 事务性原子性 | 操作要么全部成功，要么全部失败，有回滚机制 | 否              | 需要手动实现错误处理，无内置回滚            |

###  Redis 如何执行 Lua ? 

Redis使用嵌入的 Lua 解释器来运行 Lua 脚本，确保执行过程是原子的，即在脚本运行期间不会处理其他命令。用户通过 *EVAL* 或 *EVALSHA* 命令发送 Lua 脚本 ， Redis服务器接收后通过 *redis.call()* 或 *redis.pcall()* 执行Redis命令。执行期间，Redis服务器阻塞其他命令，确保执行原子性。执行完成后，返回结果给客户端。

##### EVAL 命令

- 语法

``` bash
EVAL script numkeys [key [key ...]] [arg [arg ...]]
```

- 流程

1) Redis 接收到 EVAL 命令后，会计算脚本内容的 SHA1 摘要

2) 将脚本存入缓存（键为 SHA1 摘要）

3) 执行脚本逻辑

``` bash
EVAL "return ARGV[1]" 0 hello
```

##### EVALSHA 命令


- 语法

``` bash
EVALSHA sha1 numkeys [key [key ...]] [arg [arg ...]]
```

- 流程

1) 使用 EVALSHA 前，需先用 SCRIPT LOAD 命令加载脚本

2) Redis 根据 SHA1 摘要，查找缓存的脚本

3) 若找到，直接执行脚本；若未找到，返回错误 NOSCRIPT No matching script

``` bash
redis> SCRIPT LOAD "return ARGV[1]"
"232fd51614574cf0867b83d384a5e898cfd24e5a"

redis> EVALSHA "232fd51614574cf0867b83d384a5e898cfd24e5a" 0 hello
"hello"
```


##### EVAL与EVALSHA的差异

| 特性     | EVAL                               | EVALSHA                            |
| -------- | ---------------------------------- | ---------------------------------- |
| 首次执行 | 需要发送脚本体，编译并缓存         | 需要预加载脚本，使用 SHA1 哈希执行 |
| 性能     | 首次较慢，后续可能使用缓存         | 每次执行更快，无需发送脚本体       |
| 缓存依赖 | 自动缓存，易失性，服务器重启后清空 | 依赖预加载，需确保哈希有效         |
| 使用场景 | 简单测试或一次性执行               | 频繁执行，性能敏感场景             |



### Redis 执行 Lua 注意事项

在实际使用中，开发者应注意以下几点：

- 性能优化

  脚本应尽量简短，避免长时间运行，以免阻塞其他操作。

- 错误处理

  由于没有自动回滚，开发者需要在脚本中实现错误检查。例如，使用条件语句确保所有操作成功。


- 集群兼容性

  设计脚本时，确保所有访问的键都在同一节点，否则可能导致执行失败。在 Redis 集群中，脚本的执行需要特别注意键的分布，所有访问的键必须作为输入参数明确提供，确保它们位于同一节点。这是为了维持原子性，因为集群将数据分布在多个节点，每个节点独立处理请求。例如，如果脚本尝试修改分布在不同节点的键，Redis 无法保证跨节点的原子执行。用户需要使用 Redis 集群的哈希标签功能控制键的放置，确保所有相关键在同一节点。

