---
id: 2024120601
title: Golang Concurrency - Channel
date: 2024年12月6日
image: golang.svg
tags: ["golang"]
---


### Table of Contents

- Channel Axioms
- Channel Hints


### Channel Axioms

- #### A send to a nil channel blocks forever ####

This example program will deadlock because the zero value for an uninitalised channel is nil.

``` go 

package main

func main() {
        var c chan string
        c <- "let's get started" // deadlock
}

```

- #### A receive from a nil channel blocks forever ####

Similarly receiving from a nil channel blocks the receiver forever.

``` go 

package main

import "fmt"

func main() {
        var c chan string
        fmt.Println(<-c) // deadlock
}

```

So why does this happen ? 

1) The size of a channel’s buffer is not part of its type declaration, so it must be part of the channel’s value.

2) If the channel is not initalised then its buffer size will be zero.

3) If the size of the channel’s buffer is zero, then the channel is unbuffered.

4) If the channel is unbuffered, then a send will block until another goroutine is ready to receive.

5) If the channel is nil then the sender and receiver have no reference to each other; they are both blocked waiting on independent channels and will never unblock.


- #### A send to a closed channel panics ####

The following program will likely panic as the first goroutine to reach 10 will close the channel before its siblings have time to finish sending their values.

``` go 

package main

import "fmt"

func main() {
        var c = make(chan int, 100)
        for i := 0; i < 10; i++ {
                go func() {
                        for j := 0; j < 10; j++ {
                                c <- j
                        }
                        close(c)
                }()
        }
        for i := range c {
            fmt.Println(i)
        }
}

```


- #### A receive from a closed channel returns the zero value immediately ####

Once a channel is closed, and all values drained from its buffer, the channel will always return zero values immediately.

``` go 

package main

import "fmt"

func main() {

    c := make(chan int, 3)
    c <- 1
    c <- 2
    c <- 3
    close(c)
    for i := 0; i < 4; i++ {
        fmt.Printf("%d ", <-c) // prints 1 2 3 0
    }

}

```

The correct solution to this problem is to use a for range loop.

``` go 

package main

import "fmt"

func main() {

    c := make(chan int, 3)
    c <- 1
    c <- 2
    c <- 3
    close(c)
    for v := range c {
        fmt.Printf("%d ", v) // prints 1 2 3
    }

}

```

### Channel Hints


- Closing the nil channel cause runtime panic , and Closing a closed channel cause runtime panic too .

- Do not close a channel from a receiver goroutine. Closing the channel from a receiver could make future sender goroutines to panic .

- If a channel has multiple senders, do not close the channel from a sender goroutine. Closing the channel from a sender could make future sender goroutine to panic.

- It is not required to close an unused channel. If no goroutine is left referencing the channel, it will be garbage collected. Note that it is only necessary to close a channel if the receiver is looking for a close. 

- Do not close a channel from one goroutine while writing to it from another goroutine.


### Reference

- [1] [Channel Axioms](https://dave.cheney.net/2014/03/19/channel-axioms/)
- [2] [Golang Concurrency Tricks](https://udhos.github.io/golang-concurrency-tricks/)