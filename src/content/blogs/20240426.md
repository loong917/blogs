---
id: 20240426
title: 死锁与活锁？
date: 2024年4月26日
image: programming.svg
tags: ["golang"]
---


### Deadlock

1. 死锁产生的必要条件

- Mutual Exclusion （互斥条件）

  资源一旦分配给某个进程，该进程在某一段时间内拥有对这个资源的专有权，直到该进程释放这个资源。

- Wait For Condition （请求与保持）

  进程已经占有了某个资源，同时又在请求新的资源，但对已占有的资源不释放。

- No Preemption （不可抢占）

  资源只能被占有它的进程释放，其它进程不能抢占。

- Circular Wait （循环等待）

  若干进程形成了首尾相连的循环等待资源关系。
  
2. 死锁示例

```bash

package main

import (
	"fmt"
	"sync"
	"time"
)

type value struct {
	mu    sync.Mutex
	value int
}

func main() {
	var wg sync.WaitGroup
	printSum := func(v1, v2 *value) {
		defer wg.Done()
		v1.mu.Lock()
		defer v1.mu.Unlock()
		time.Sleep(2 * time.Second)
		v2.mu.Lock()
		defer v2.mu.Unlock()
		fmt.Printf("sum=%v\n", v1.value+v2.value)
	}
	var a, b value
	wg.Add(2)
	go printSum(&a, &b)
	go printSum(&b, &a)
	wg.Wait()
}

```

3.为什么发生死锁？

![死锁图解](/20240426死锁图解.png)

在上面的示例中，我们创建了2个goroutine。一个goroutine执行printSum时，锁住了a, 同时试图再去锁b。另一个goroutine执行printSum时，锁住了b, 同时试图再去锁a。两个goroutine都在等待对方释放资源，所以发生了死锁。